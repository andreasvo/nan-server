#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <string.h>
#include <sqlite3.h>

// Handles XML/SQL request for webserver "server.c", called by "handler.c"
// Andreas Vestgarden Olsen (March 2017)

void xml_handle();

static int callback(void *NotUsed, int argc, char **argv, char **azColName){
   int i;
   for(i=0; i<argc; i++){
      printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
   }
   printf("\n");
   return 0;
}

int main() {
   xml_handle();
}

void xml_handle() {

    int size = 500;
    int i, j, id, tlf, input_size, name_status;
    char* xml_buf;
    char* temp;
    char* sql_sentence;
    xml_buf = (char*) malloc(size);
    int fd = open("./persons.xml", O_RDONLY);
    int bytes = read(fd, xml_buf, size);

    xml_buf = (char*) realloc(xml_buf, bytes);

    // input extraction
    for (i = 0; i < bytes; i++) {
        
        if (xml_buf[i] == '<' && xml_buf[i+1] == '/' && xml_buf[i+2] == 'P' && xml_buf[i+3] == 'h') {
            printf("breaking");
            break;
        }
        
        // id extraction
        if (xml_buf[i] == '<' && xml_buf[i+1] == 'i' && xml_buf[i+2] == 'd' && xml_buf[i+3] == '>') {
            j = i+4;
            while (xml_buf[j] != '<') {
                input_size++;
                j++;
            }
            temp = (char*) malloc(input_size);
            memcpy(temp, xml_buf+(i+4), input_size);
            id = atoi(temp);
        }

        //printf("\nTLF Extraction");
        // tlf extraction
        if (xml_buf[i] == '<' && xml_buf[i+1] == 't' && xml_buf[i+2] == 'l' && xml_buf[i+3] == 'f' && xml_buf[i+4] == '>') {
            j = i+5;
            input_size = 0;
            while (xml_buf[j] != '<') {
                input_size++;
                j++;
            }
            temp = (char*) malloc(input_size);
            memcpy(temp, xml_buf+(i+5), input_size);
            tlf = atoi(temp);
        }

        //printf("\nName Extraction");
        // name extraction
        if (xml_buf[i] == '<' && xml_buf[i+1] == 'n' && xml_buf[i+2] == 'a' && xml_buf[i+3] == 'm' && xml_buf[i+4] == 'e' && xml_buf[i+5] == '>') {
            j = i+6;
            input_size = 0;
            while (xml_buf[j] != '<') {
                input_size++;
                j++;
            }
            free(temp);
            temp = (char*) malloc(input_size);
            
            if (0 < input_size) {
                memcpy(temp, xml_buf+(i+6), input_size);
            } else {
                name_status = -1;
            }
        }

    }

    printf("ID: %d", id);
    printf("\nTLF: %d", tlf);
    printf("\nName: %s\n", temp);

    printf("\nSQL Handling\n");
    // SQL handling
    sqlite3* db;
    char *zErrMsg;
    int rc;

    rc = sqlite3_open("/home/andreas/webroot/database.db", &db);
    printf("%d", rc);
/*
    if (rc) {
        printf("---Can't open database: %s\n", sqlite3_errmsg(db));
    } else {
        printf("---Opened database successfully\n");
    }

    
    sql_sentence = (char*) malloc(256);

    printf("\nMake SQL Sentence");
    // makes the actual sql sentence
    if (-1 == name_status) {
        sprintf(sql_sentence, "INSERT OR REPLACE INTO Phonebook(id, tlf) VALUES(%d, %d);", id, tlf);
    } else {
        sprintf(sql_sentence, "INSERT OR REPLACE INTO Phonebook(id, tlf, name) VALUES(%d, %d, '%s');", id, tlf, temp);
    }

    printf("\nExecute SQL");
    // Execute SQL statement
    rc = sqlite3_exec(db, sql_sentence, callback, 0, &zErrMsg);

    if( rc != SQLITE_OK ) {
        printf("-->SQL error: %s\n", zErrMsg);
        sqlite3_free(zErrMsg);
    } else {
        printf("-->\nRecords created successfully\n");
    }

    sqlite3_close(db);*/
}